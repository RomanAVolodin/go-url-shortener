
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>shortener: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/RomanAVolodin/go-url-shortener/cmd/shortener/main.go (0.0%)</option>
				
				<option value="file1">github.com/RomanAVolodin/go-url-shortener/internal/shortener/config/settings.go (66.7%)</option>
				
				<option value="file2">github.com/RomanAVolodin/go-url-shortener/internal/shortener/handlers/shortener.go (100.0%)</option>
				
				<option value="file3">github.com/RomanAVolodin/go-url-shortener/internal/shortener/handlers/shortener_handlers.go (88.0%)</option>
				
				<option value="file4">github.com/RomanAVolodin/go-url-shortener/internal/shortener/repositories/file_repository.go (87.9%)</option>
				
				<option value="file5">github.com/RomanAVolodin/go-url-shortener/internal/shortener/repositories/in_memory_repository.go (100.0%)</option>
				
				<option value="file6">github.com/RomanAVolodin/go-url-shortener/internal/shortener/utils/repository.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "github.com/RomanAVolodin/go-url-shortener/internal/shortener/config"
        "github.com/RomanAVolodin/go-url-shortener/internal/shortener/handlers"
        "github.com/RomanAVolodin/go-url-shortener/internal/shortener/utils"
        "log"
        "net/http"
)

func main() <span class="cov0" title="0">{
        repo, backRepo := utils.SetRepositories()
        h := handlers.NewShortenerHandler(repo, backRepo)
        log.Printf("Server started at %s", config.Settings.ServerAddress)
        log.Fatal(http.ListenAndServe(config.Settings.ServerAddress, h))
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "github.com/caarlos0/env/v6"
        "log"
)

const (
        OnlyGetPostRequestAllowedError = "Only GET/POST requests allowed"
        RequestBodyEmptyError          = "Request body is empty"
        BadInputData                   = "Incorrect request body data"
        UnknownError                   = "Something bad's happened"
        NoURLFoundByID                 = "No url found by id"
)

type AppSettings struct {
        ServerAddress   string `env:"SERVER_ADDRESS" envDefault:"localhost:8080"`
        BaseURL         string `env:"BASE_URL" envDefault:"http://localhost:8080"`
        FileStoragePath string `env:"FILE_STORAGE_PATH"`
}

var Settings AppSettings

func init() <span class="cov10" title="2">{
        err := env.Parse(&amp;Settings)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "github.com/RomanAVolodin/go-url-shortener/internal/shortener/config"
        repo "github.com/RomanAVolodin/go-url-shortener/internal/shortener/repositories"
        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
        "net/http"
)

type ShortenerHandler struct {
        *chi.Mux
        Repo     repo.Repository
        BackRepo repo.Repository
}

func NewShortenerHandler(repo repo.Repository, backRepo repo.Repository) *ShortenerHandler <span class="cov10" title="20">{
        h := &amp;ShortenerHandler{
                Mux:      chi.NewMux(),
                Repo:     repo,
                BackRepo: backRepo,
        }
        h.Use(middleware.RequestID)
        h.Use(middleware.RealIP)
        h.Use(middleware.Logger)
        h.Use(middleware.Recoverer)

        h.Get("/{id}", h.RetrieveShortURLHandler)
        h.Post("/", h.CreateShortURLHandler)
        h.Post("/api/shorten", h.CreateJSONShortURLHandler)
        h.MethodNotAllowed(func(writer http.ResponseWriter, request *http.Request) </span><span class="cov5" title="4">{
                http.Error(writer, config.OnlyGetPostRequestAllowedError, http.StatusMethodNotAllowed)
        }</span>)
        <span class="cov10" title="20">return h</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "encoding/json"
        "github.com/RomanAVolodin/go-url-shortener/internal/shortener/config"
        "github.com/go-chi/chi/v5"
        "io"
        "net/http"
)

type ShortenerCreateDTO struct {
        URL string `json:"url"`
}

type ShortenerResponseDTO struct {
        Result string `json:"result"`
}

func (h *ShortenerHandler) CreateJSONShortURLHandler(
        w http.ResponseWriter,
        r *http.Request,
) <span class="cov8" title="8">{
        requestBody, doneWithError := h.readBody(w, r)
        if doneWithError </span><span class="cov4" title="3">{
                return
        }</span>
        <span class="cov6" title="5">var createDTO ShortenerCreateDTO
        if err := json.Unmarshal(requestBody, &amp;createDTO); err != nil || createDTO.URL == "" </span><span class="cov3" title="2">{
                http.Error(w, config.BadInputData, http.StatusUnprocessableEntity)
                return
        }</span>

        <span class="cov4" title="3">var id string
        if link, exist := h.BackRepo.GetByID(createDTO.URL); exist </span><span class="cov1" title="1">{
                id = link
        }</span> else<span class="cov3" title="2"> {
                id = h.saveToRepositories([]byte(createDTO.URL))
        }</span>

        <span class="cov4" title="3">responseDTO := ShortenerResponseDTO{Result: h.generateResultURL(r, id)}
        jsonResponse, err := json.Marshal(responseDTO)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, config.UnknownError, http.StatusBadRequest)
                return
        }</span>
        <span class="cov4" title="3">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        w.Write(jsonResponse)</span>
}

func (h *ShortenerHandler) CreateShortURLHandler(
        w http.ResponseWriter,
        r *http.Request,
) <span class="cov6" title="4">{
        urlToEncode, doneWithError := h.readBody(w, r)
        if doneWithError </span><span class="cov1" title="1">{
                return
        }</span>
        <span class="cov4" title="3">w.WriteHeader(http.StatusCreated)

        if link, exist := h.BackRepo.GetByID(string(urlToEncode)); exist </span><span class="cov1" title="1">{
                w.Write([]byte(h.generateResultURL(r, link)))
                return
        }</span>

        <span class="cov3" title="2">id := h.saveToRepositories(urlToEncode)

        _, err := w.Write([]byte(h.generateResultURL(r, id)))
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, config.UnknownError, http.StatusInternalServerError)
                return
        }</span>
}

func (h *ShortenerHandler) RetrieveShortURLHandler(
        w http.ResponseWriter,
        r *http.Request,
) <span class="cov6" title="4">{
        urlID := chi.URLParam(r, "id")
        if link, exist := h.Repo.GetByID(urlID); exist </span><span class="cov3" title="2">{
                w.Header().Set("Location", link)
                w.WriteHeader(http.StatusTemporaryRedirect)
                return
        }</span>
        <span class="cov3" title="2">http.Error(w, config.NoURLFoundByID, http.StatusNotFound)</span>
}

func (h *ShortenerHandler) saveToRepositories(urlToEncode []byte) string <span class="cov6" title="4">{
        id := h.Repo.CreateSave(string(urlToEncode))
        h.BackRepo.Save(string(urlToEncode), id)
        return id
}</span>

func (h *ShortenerHandler) readBody(w http.ResponseWriter, r *http.Request) (body []byte, doneWithError bool) <span class="cov10" title="12">{
        urlToEncode, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, config.UnknownError, http.StatusBadRequest)
                return nil, true
        }</span>
        <span class="cov10" title="12">defer r.Body.Close()

        if string(urlToEncode) == "" </span><span class="cov6" title="4">{
                http.Error(w, config.RequestBodyEmptyError, http.StatusBadRequest)
                return nil, true
        }</span>
        <span class="cov8" title="8">return urlToEncode, false</span>
}

func (h *ShortenerHandler) generateResultURL(r *http.Request, id string) string <span class="cov7" title="6">{
        return config.Settings.BaseURL + "/" + id
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package repositories

import (
        "encoding/json"
        "errors"
        "github.com/lithammer/shortuuid"
        "io"
        "log"
        "os"
        "path/filepath"
)

type FileRepository struct {
        Storage  map[string]string
        FilePath string
}

func (repo *FileRepository) GetByID(id string) (string, bool) <span class="cov5" title="4">{
        lock.RLock()
        result, exist := repo.Storage[id]
        lock.RUnlock()
        return result, exist
}</span>

func (repo *FileRepository) CreateSave(url string) string <span class="cov3" title="2">{
        shortURL := shortuuid.New()
        repo.Save(shortURL, url)
        return shortURL
}</span>

func (repo *FileRepository) Save(key, value string) <span class="cov5" title="4">{
        lock.Lock()
        repo.Storage[key] = value
        lock.Unlock()

        file := repo.openStorageFile()
        defer file.Close()
        encoder := json.NewEncoder(file)
        encoder.SetIndent("", " ")
        if err := encoder.Encode(&amp;repo.Storage); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}

func (repo *FileRepository) Restore() <span class="cov9" title="14">{
        file := repo.openStorageFile()
        defer file.Close()
        decoder := json.NewDecoder(file)
        if err := decoder.Decode(&amp;repo.Storage); err == io.EOF </span><span class="cov5" title="4">{
                log.Println("State restored")
        }</span> else<span class="cov8" title="10"> if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}

func (repo *FileRepository) openStorageFile() *os.File <span class="cov10" title="18">{
        path := "storages"
        if _, err := os.Stat(path); errors.Is(err, os.ErrNotExist) </span><span class="cov3" title="2">{
                err := os.Mkdir(path, os.ModePerm)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err)
                }</span>
        }
        <span class="cov10" title="18">pathToFile := filepath.Join(path, repo.FilePath)
        file, err := os.OpenFile(pathToFile, os.O_RDWR|os.O_CREATE, 0777)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov10" title="18">return file</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package repositories

import (
        "github.com/lithammer/shortuuid"
        "sync"
)

type InMemoryRepository struct {
        Storage map[string]string
}

var lock = sync.RWMutex{}

func (repo *InMemoryRepository) GetByID(id string) (string, bool) <span class="cov10" title="6">{
        lock.RLock()
        result, exist := repo.Storage[id]
        lock.RUnlock()
        return result, exist
}</span>

func (repo *InMemoryRepository) CreateSave(url string) string <span class="cov4" title="2">{
        shortURL := shortuuid.New()
        repo.Save(shortURL, url)
        return shortURL
}</span>

func (repo *InMemoryRepository) Save(key, value string) <span class="cov7" title="4">{
        lock.Lock()
        repo.Storage[key] = value
        lock.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package utils

import (
        "github.com/RomanAVolodin/go-url-shortener/internal/shortener/config"
        "github.com/RomanAVolodin/go-url-shortener/internal/shortener/repositories"
        "log"
)

func SetRepositories() (repositories.Repository, repositories.Repository) <span class="cov10" title="2">{
        if config.Settings.FileStoragePath == "" </span><span class="cov1" title="1">{
                repo := repositories.InMemoryRepository{Storage: make(map[string]string)}
                backwardRepo := repositories.InMemoryRepository{Storage: make(map[string]string)}

                log.Println("In memory storage`s been chosen")
                return &amp;repo, &amp;backwardRepo
        }</span>

        <span class="cov1" title="1">repo := repositories.FileRepository{
                Storage:  make(map[string]string),
                FilePath: config.Settings.FileStoragePath,
        }
        repo.Restore()

        backwardRepo := repositories.FileRepository{
                Storage:  make(map[string]string),
                FilePath: "back_" + config.Settings.FileStoragePath,
        }
        backwardRepo.Restore()

        log.Println("File storage`s been  chosen")
        return &amp;repo, &amp;backwardRepo</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
